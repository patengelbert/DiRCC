#
# Reset and stop the system.
#
reset system
stop
#wait 30s

#
# Disable semihosting.
#
set semihosting enabled false

#
# Load the SPL preloader into memory.
#
loadfile "/home/patrick/Documents/Coursework/DiRCC/software/spl_bsp/uboot-socfpga/spl/u-boot-spl" 0x0
#loadfile "$sdir/u-boot-spl_demo" 0x0
#loadfile "$sdir/u-boot-spl_rtos" 0x0

#
# set pc to entry point
#
#set debug-from *$entrypoint     # Set start-at setting to address of $entrypoint
#start 

#
# Enable semihosting.
#
set semihosting enabled true
set debug-from *$entrypoint 
#
# Delete any existing breakpoints.
#
delete

#
# Set a breakpoint in the SPL function spl_boot_device(). This function is
# called right before the SPL tries to load the next stage in the preloader.
#
tbreak spl_boot_device

#
# Set the PC to the entry point and go.
#
run
#cont

#
# Wait for the breakpoint.
#
wait
#wait 20s

# Create function to deassert fpga bridge reset
#define fpga_bridges_deassert_reset
#   print "FPGA Bridges: Deassert Reset"
#   set var $Peripherals::$reset_manager::$reset_manager_brgmodrst.hps2fpga = 0
#   set var $Peripherals::$reset_manager::$reset_manager_brgmodrst.lwhps2fpga = 0
#   set var $Peripherals::$reset_manager::$reset_manager_brgmodrst.fpga2hps = 0
#end

# Deassert fpga bridge reset if the fpga is configured
#if $Peripherals::$fpgamgrregs::$fpgamgrregs_stat!=0x0
#   print "FPGA is Configured"
#   fpga_bridges_deassert_reset
#else
#   print "FPGA is not Configured"
#end


#
# Load the demo program.
#
loadfile "$sdir/Debug/dircc_hps.axf"
set $pc=$entrypoint

#tbreak prvIdleTask
#tbreak prvTimerTask
#tbreak xPortStartScheduler

#tbreak vPortRestoreTaskContext
#tbreak vTaskSwitchContext



#
# Run the target and break at main().
#
start
